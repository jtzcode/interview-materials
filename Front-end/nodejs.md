## Node.js 经典面试题

### Node的模块加载
- 先计算模块路径
- 如果在缓存里，从缓存取出
- 加载模块（这里首先会生成一个Module对象，并存入缓存，然后加载模块本身）
- 输出模块的exports属性
- 默认情况下，Node准备的exports和module.exports是同一个对象，并初始化为空对象。如果导出对象，则使用二者均可往对象里增加字段（因为二者引用相同）。如果导出函数或者数组，则需要赋值给module.exports，而不能直接赋值exports。因此，为了方便起见，总是使用module.exports可以应对所有情况。

### Node异步I/O
- Node进程启动时，就会创建类似while(true)的循环，每一次循环叫做一次tick。
- 每次循环都会检查是否有事件需要处理，如果有就执行事件对应的回调函数，没有就退出进程。

#### 如何判断是否有事件需要处理
- 每个事件循环中有一个或多个观察者，每次tick就向这些观察者询问是否有事件需要处理。
- Node中常见的观察者类型有网络、文件I/O等。
- 事件循环就是一个生产者/消费者模型，异步I/O就是生产者，提供各种类型事件，I/O执行的结果被封装，发送给观察者，事件循环是消费者，从观察者那里取出回调函数并执行。
- 底层在Windows上基于IOCP，Linux则基于libuv。

### V8的垃圾回收
- V8在64位系统的内存是1.4G，在32位上是0.7G。这样设计的原因是，堆内存是1.5G时，垃圾回收要花费50ms以上，非增量的垃圾回收甚至要1秒以上。这个过程会阻塞JavaScript线程的执行，因此要限制总的内存大小。
- 内存回收算法：新生代、老生代。新生代一分为二，检查From中的存活对象，复制到To，非存活的销毁，交换From和To的角色。一个对象多次复制后依然存活，则移动到老生代。老生代采取标记清除法，遍历堆上所有对象，标记需要清理的对象（少数），清理后还需要整理内存，防止内存碎片。
- 闭包和全局变量的内存不能立即回收，可能是内存泄露的来源。
- 事件重复监听而忘记移除，也可能导致内存泄露。（使用node的http模块，配置keepalive时要注意）

### Buffer模块
- 新建的buffer属于堆外内存，不是V8分配的。
- Buffer.allocUnsafe分配的实例底层是未初始化的，而alloc方法是以零值初始化的实例。
- Buffer的内存分配：采用slab动态内存机制：以8KB位界限，小于8K就直接复用slab，减少了分配内存系统调用的次数。大于8K则直接分配一个新的slab，使用C++底层的分配方法。
- 设置读取流的Encoding为UTF-8可以避免乱码。

### Express框架
#### Express的特点
- 路由系统
- 专注高性能（设计思路）
- 广泛的测试覆盖率（设计思路）
- HTTP 助手（重定向、缓存、内容协商等）
- 模板引擎（14+种）
- 脚手架工具

#### Express的中间件能力
- Express也支持中间件能力，在路由的回调函数里面传入一个next方法，然后在处理结束后调用next，next的定义使用路由函数（get）的第三个参数。
- Express的中间件类似洋葱模型，在外层中间件调用next后，会进入内层中间件，全部执行过后返回外层，可以继续执行外层next后面的代码（比如做一些统计工作）。
- 一个例子：https://gitee.com/geektime-geekbang/geek-nodejs/blob/master/section21/index.js
- Express中间件不支持异步操作

### Koa框架
#### Koa的核心功能
- 解决Express不支持异步中间件的问题
- 支持Context，可以用于在中间件之间传递变量
- Koa只是个框架，不会绑定任何中间件，包括路由。
- 使用路由功能需要依赖koa-mount包来完成。
- 一个例子：https://gitee.com/geektime-geekbang/geek-nodejs/blob/master/section22/index.js